#!/bin/bash

# /usr/bin/rolekeeper --- command to add and remove virtual IP address aliases
# to network cards.

# rolekeeper status --- list all of the roles and the current state.
# rolekeeper enable <role> --- Tries to acquire the virtual IP belonging to a role (run this as root)
# rolekeeper disable <role> --- releases a virtual IP (run this as root)

instance=
usage=0
force=0
verbosity=0
ip_command=/sbin/ip
commands="$(readlink -f "$(dirname $0)")/../share/vizrt/vosa/commands"

function debug() {
  if [ "$verbosity" != "0" ] ; then
    echo >&2 "${@}"
  fi
}

### To add an option, add it to the optstring, as defined in getopts, in alphabetical order.
### Also add a function "option-x" where x is the option. $1 will be the option value, if any.
### set any variables needed to default values as globals first.
OPTSTRING=":fhv"

function option-f() {
  force=1
}

function option-h() {
  usage=1
}

function option-v() {
  verbosity=$((verbosity + 1))
}

function unknown-option() {
  echo "Unknown option $@"
  usage=1
}

available_dir=$(dirname $0)/../../etc/vizrt/roles-available.d
available_dir=$(readlink -f ${available_dir})
enabled_dir=$(dirname $0)/../../etc/vizrt/roles-enabled.d
enabled_dir=$(readlink -f ${enabled_dir})

### To add a command, simply define a function with a do_ prefix.

## Provides instant gratification.
function do_help() {
  cat <<EOF
$(basename $0) is a command to manage virtual IP addresses of a
machine.

Useful starting points:
 - $(basename $0) status
 - $(basename $0) init
 - $(basename $0) enable <role>
 - $(basename $0) disable <role>
EOF
}

## Initializes the etc directory with the required directory structure
##
## Creates /etc/vizrt/roles-available.d, enabled.d and a skeleton directory
## with a documented set of files.  The files and directories are not
## overwritten if they already exist.
function do_init() {
  mkdir -v -p /etc/vizrt/roles-available.d || exit 2
  mkdir -v -p /etc/vizrt/roles-enabled.d || exit 2
}

## Provides even more help.
function do_longhelp() {
  cat <<EOF
$(basename "$0") is a command to manage virtual IP addresses

EOF
  echo "$0 supports these commands:"
  declare -F | grep ^"declare -f do_" | cut -d ' ' -f3 | cut -d'_' -f2 | sort | \
      while read f; do
    echo -n ' * '$f:  # first line on the same as the command.
    awk -f $commands/help.awk fn=do_$f < $0
    echo
  done
}

## List detailed information on how to use all the commands.
function do_commands() {
  declare -F | grep ^"declare -f do_" | cut -d ' ' -f3 | cut -d'_' -f2 | sort | \
      while read f; do
    echo -n ' * '$f:  # first line on the same as the command.
    awk -f $commands/help.awk fn=do_$f < $0 | head -n 1
  done
}



#### helper commands

# Verifies that the installation is sane, and that required
# directories are there.
function verify_installation() {
  if [ -z "$available_dir" -o ! -r "$available_dir" ] ; then
    echo "Not initialized! RTFM! Exiting. ($available_dir)"
    exit 2
  fi

  if [ -z "$enabled_dir" -o ! -r "$enabled_dir" ] ; then
    echo "Not initialized! RTFM! Exiting. ($enabled_dir)"
    exit 2
  fi
}

# called if a role name argument is required; exits if it isn't
# specified, or that it doesn't have a role.conf file.
function requires_role_name() {
  if [ -z "$instance" ] ; then
    echo "Missing role"
    exit 2
  fi
  if [ ! -r "${available_dir}/$instance/role.conf" ] ; then
    echo "Missing ${available_dir}/$instance/role.conf"
    exit 2
  fi
}

# Returns 0 or 1 based on the pingability of an IP passed as $1.
# Might in future use arp table to verify presence of IPs.
function determine_presence_of() {
  ping -q -c 1 -w 1 "$1" 2>&1 > /dev/null
  if [ $? -eq 0 ] ; then
    return 0
  else
    return 1
  fi
}

# echos the IP address of the hostname passed as $1, suitable for
# ifconfig up'ing
function determine_ip_of_hostname() {
  local ip
  local hostnames
  while read ip hostnames
  do
    hostnames=( $hostnames )
    for a in "${hostnames[@]}" ; do
      if [ "$1" == "$a" ] ; then
        echo "$ip"
        return
      fi
    done
  done <<< "$(grep -v ^# /etc/hosts)"
}

# Prints out the status of a single role, in the form
# <role-name> onboot|manual on|off|unknown
# argument is the name of a directory in /etc/vizrt/roles-available.d/
function really_do_status () {
    local output
    local done=0
    local a
    local avdir="${available_dir}/$1"
    output=( $1 )
    if [ ! -d "$avdir" ] ; then
      done=1
    fi

    if [ $done -eq 0 ] ; then
      for a in "${enabled_dir}"/*"$1" ; do
        if [ -L "$a" ] ; then
          output=( ${output[@]} onboot );
        else
          output=( ${output[@]} manual );
        fi
      done
    fi

    if [ $done -eq 0 ] ; then
      a="$(determine_ip_of_hostname $1)"
      if [ -z "$a" ] ; then
        output=( ${output[@]} unknown_host )
        done=1
      fi
    fi

    if [ $done -eq 0 ] ; then
      $ip_command addr list | grep -q "inet $a/"
      a="${PIPESTATUS[1]}"
      if [ "$a" == "0" ] ; then
        output=( ${output[@]} on )
      else
        output=( ${output[@]} off )
      fi
    fi

    echo "${output[@]}"
}



### public commands (all start with "do_")


## Brings up all the interfaces that are set to "onboot"
##
## Goes through the list of interfaces listed in
## /etc/vizrt/roles-enabled.d/ and does the equivalent of an enable on
## them.
##
## The first one to fail will cause the ripple effect of not bringing
## up the rest of the interfaces; this is to avoid causing problems
## like deadlocks caused by two machines trying (on boot) to compete
## for various services, but rather to fail fast(er) if an interface
## is busy.
function do_auto() {
  verify_installation
  for instance in ${enabled_dir}/* ; do 
    instance="$(basename "$(readlink -f "$instance")")"
    echo "enabling $instance"
    do_enable $instance || exit 2
  done
}

## Shows the status of all the roles known to the local machine.
##
##   rolekeeper status
##
## For all defined roles, i.e. each directory in
## /etc/vizrt/roles-available.d, the status of each role is printed,
## in the following form:
##
##    <role-name>  <initial-state>  <current-state>
##
## where
## - <role-name> is the name of the role, also the hostname of the role.
## - <boot-state> is either "onboot" or "manual".  "onboot" means that
##   the role should be acquired when the machine boots, whereas
##   "manual" indicates that it should _not_ be acquired upon boot, but
##   rather through operator intervention.
## - <current-state> is either "on", "off" or "unknown_host":  "on"
##   indicates that the machine currently plays this role, effectively
##   the IP address of the role is assigned to the local machine; "off"
##   indicates that the role is _not_ being played by the local machine;
##   "unknown_host" means that the role name could not be resolved to an
##   IP, so is invalid.
##
## Example output:
##    edit
function do_status() {
  verify_installation
  if [ -z "$instance" ] ; then
    local a
    for a in ${available_dir}/* ; do
      if [ -d "$a" ] ; then
        really_do_status "$(basename "$a")"
      fi
    done
  else
    really_do_status "$instance"
  fi
}


## Enables an instance by bringing it up.
##
function do_enable() {
  verify_installation
  requires_role_name
  # start the interface using ifup or something
  # TODO: 
  unset INTERFACE
  . "$available_dir/$instance/role.conf"
  ip="$(determine_ip_of_hostname $instance)"
  if [ -z "$ip" ] ; then
    echo "Unable to determine IP for hostname $instance"
    exit 2
  fi
  # Determine if $INTERFACE is already up locally
  status=( $(really_do_status $instance) )
  if [ "${status[2]}" == "on" ] ; then
    echo "$instance is already enabled."
    exit 0
  fi

  determine_presence_of $ip
  if [ "$PIPESTATUS" == 0 ] ; then
    echo "$instance is already alive somewhere else"
    exit 2
  fi

  # actually bring it up
  ifconfig $INTERFACE up $ip
}


## Deactivates the network alias if it existed.
##
## rolekeeper deactivate myrole
function do_disable() {
  verify_installation
  requires_role_name
  # stop the interface using ifup or something
  unset INTERFACE
  . "$available_dir/$instance/role.conf"

  # bring it down
  ifconfig $INTERFACE down
}



function unknown-argument() {
  echo "Unknown argument $@"
  usage=1
}

LASTOPTIND=0

function parseopts() {
local OPTARG
local OPTIND
local opt
local currentconfigdirectory="${@:1:1}"
shift;
while getopts "${OPTSTRING}" opt; do
  case $opt in
    \?)
      unknown-option "-$OPTARG"
      ;;
    *)
      option-$opt "${OPTARG}"
      ;;
  esac
done

LASTOPTIND=$OPTIND

}

function verify_usage() {
  if [ $usage -eq 1 ] ; then
    echo "Usage: $0 [-i <instance-dir>] <command>"
    echo "$0 help for more help"
    exit 1;
  fi
}

parseopts "$PWD" "${@}"

# get rid of all parsed parameters from command line, leaving real arguments
shift $((LASTOPTIND-1))

if [ $usage -eq 0 -a "${#@}" -lt 1 ] ; then
  echo "A command must be specified."
  usage=1
fi

verify_usage

debug "available_dir=$available_dir"

cmd="${1}"
instance="$2"
if [ ! -z "$cmd" ] ; then
  # Check if the command
  fn="do_${cmd}"
  declare > /dev/null -f "$fn" || unknown-argument "$1"
  declare > /dev/null -f "$fn" && "$fn" 
  verify_usage
fi




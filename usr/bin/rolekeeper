#!/bin/bash

# /usr/bin/rolekeeper --- command to add and remove virtual IP address aliases
# to network cards.

# rolekeeper list --- list roles and their state.
# rolekeeper enable <role> --- Tries to acquire the virtual IP belonging to a role
# rolekeeper disable <role> --- releases a virtual IP.

instance_dir=
instance_name=
usage=0
force=0
verbosity=0
commands="$(readlink -f "$(dirname $0)")/../share/vizrt/vosa/commands"

function debug() {
  if [ "$verbosity" != "0" ] ; then
    echo >&2 "${@}"
  fi
}

### To add an option, add it to the optstring, as defined in getopts, in alphabetical order.
### Also add a function "option-x" where x is the option. $1 will be the option value, if any.
### set any variables needed to default values as globals first.
OPTSTRING=":fhv"

function option-f() {
  force=1
}

function option-h() {
  usage=1
}

function option-v() {
  verbosity=$((verbosity + 1))
}

function unknown-option() {
  echo "Unknown option $@"
  usage=1
}

available_dir=$(dirname $0)/../../etc/vizrt/roles-available.d
available_dir=$(readlink -f ${available_dir})
enabled_dir=$(dirname $0)/../../etc/vizrt/roles-enabled.d
enabled_dir=$(readlink -f ${enabled_dir})

### To add a command, simply define a function with a do_ prefix.

## Provides instant gratification.
function do_help() {
  cat <<EOF
$(basename $0) is a command to manage virtual IP addresses of a
machine.

Useful starting points:
 - $(basename $0) 
 - $(basename $0) init
 - $(basename $0) enable <role>
 - $(basename $0) disable <role>
EOF
}

## Initializes the etc directory with the required directory structure
##
## Creates /etc/vizrt/roles-available.d, enabled.d and a skeleton directory
## with a documented set of files.  The files and directories are not
## overwritten if they already exist.
function do_init() {
  mkdir -p /etc/vizrt/roles-available.d || exit 2
  mkdir -p /etc/vizrt/roles-enabled.d || exit 2
}

## Provides even more help.
function do_longhelp() {
  cat <<EOF
$(basename "$0") is a command to manage virtual IP addresses

EOF
  echo "$0 supports these commands:"
  declare -F | grep ^"declare -f do_" | cut -d ' ' -f3 | cut -d'_' -f2 | sort | \
      while read f; do
    echo -n ' * '$f:  # first line on the same as the command.
    awk -f $commands/help.awk fn=do_$f < $0
    echo
  done
}

## List detailed information on how to use all the commands.
function do_commands() {
  declare -F | grep ^"declare -f do_" | cut -d ' ' -f3 | cut -d'_' -f2 | sort | \
      while read f; do
    echo -n ' * '$f:  # first line on the same as the command.
    awk -f $commands/help.awk fn=do_$f < $0 | head -n 1
  done
}

function verify_installation() {
  if [ -z "$available_dir" -o ! -r "$available_dir" ] ; then
    echo "Not initialized! RTFM! Exiting. ($available_dir)"
    exit 2
  fi

  if [ -z "$enabled_dir" -o ! -r "$enabled_dir" ] ; then
    echo "Not initialized! RTFM! Exiting. ($enabled_dir)"
    exit 2
  fi
}

## Lists all roles known to the local machine.
##
## More text...
## TODO:
function do_list() {
  verify_installation
  if [ -z "$instance_dir" ] ; then
    local a
    for a in ${available_dir}/* ; do 
      really_do_status "$a"
    done
  else
    really_do_status $instance_dir
  fi
}


# argument is the full path to an /etc/vizrt/roles-available.d/filename
function really_do_status () {
    local output
    local done=0
    local a
    local avdir="${available_dir}/$(basename $1)"
    output=( $(basename $1) )
    if [ ! -d "$avdir" ] ; then
      done=1
    fi

    if [ $done -eq 0 ] ; then
      for a in ${enabled_dir}/*$(basename $1) ; do
        if [ -L "$a" ] ; then
          output=( ${output[@]} onboot );
        else
          output=( ${output[@]} manual );
        fi
      done
    fi

    if [ $done -eq 0 ] ; then
      output=( ${output[@]} inactive );

      # TODO: ping it or check the arp cache to see if it's in use.
    fi

    echo ${output[@]}
}

function requires_role_name() {
  if [ -z "$instance" ] ; then
    echo "Missing role"
    exit 2
  fi
  if [ ! -r "${available_dir}/$instance/role.conf" ] ; then
    echo "Missing ${available_dir}/$instance/role.conf"
    exit 2
  fi
}

## Tells vosa that it is allowed to install and run an instance.
##
function do_enable() {
  verify_installation
  requires_role_name
  # rea the configuratin of the role
  # start the interface using ifup or something
  # TODO: 
  unset INTERFACE
  . "$available_dir/$instance/role.conf"
  echo "ifconfig $INTERFACE up <ip-of-$instance>"
}


## Deactivates the network alias if it existed.
##
## vosa deactivate instance
function do_disable() {
  verify_installation
  requires_role_name || exit 2
  if [ ! -d ${available_dir}/$instance_name ] ; then
    echo "$instance_name is not an available instance"
    exit 1
  fi
  # TODO: ifconfig $interface down
}



function unknown-argument() {
  echo "Unknown argument $@"
  usage=1
}

LASTOPTIND=0

function parseopts() {
local OPTARG
local OPTIND
local opt
local currentconfigdirectory="${@:1:1}"
shift;
while getopts "${OPTSTRING}" opt; do
  case $opt in
    \?)
      unknown-option "-$OPTARG"
      ;;
    *)
      option-$opt "${OPTARG}"
      ;;
  esac
done

LASTOPTIND=$OPTIND

}

function verify_usage() {
  if [ $usage -eq 1 ] ; then
    echo "Usage: $0 [-i <instance-dir>] <command>"
    echo "$0 help for more help"
    exit 1;
  fi
}

parseopts "$PWD" "${@}"

# get rid of all parsed parameters from command line, leaving real arguments
shift $((LASTOPTIND-1))

if [ $usage -eq 0 -a "${#@}" -lt 1 ] ; then
  echo "A command must be specified."
  usage=1
fi

verify_usage

debug "available_dir=$available_dir"

cmd="${1}"
instance="$2"
if [ ! -z "$cmd" ] ; then
  # Check if the command
  fn="do_${cmd}"
  declare > /dev/null -f "$fn" || unknown-argument "$1"
  declare > /dev/null -f "$fn" && "$fn" 
  verify_usage
fi



